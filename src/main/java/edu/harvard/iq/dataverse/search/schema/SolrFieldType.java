package edu.harvard.iq.dataverse.search.schema;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * This class depicts actual <fieldType> entries in schema.xml.
 *
 * Note: It is not necessary to have a precise XML representation of all fields possible for now.
 *       Instead, we will only use aspects that are important to us, so we can use it for validation.
 *       Down the road, it might be interesting to define and configure some <fieldType> completely
 *       via Managed Schema API.
 */
public enum SolrFieldType {
        /**
     * @todo: make this configurable from text_en to text_general or
     * non-English languages? We changed it to text_en to improve English
     * language searching in https://github.com/IQSS/dataverse/issues/444
     * <p>
     * We want to get away from always using "text_en" (especially to
     * support range queries) in
     * https://github.com/IQSS/dataverse/issues/370
     */
    STRING("string", "solr.StrField", Map.of(Property.DOCVALUES, true)),
    INTEGER("pint", "solr.IntPointField", Map.of(Property.DOCVALUES, true)),
    LONG("plong", "solr.LongPointField", Map.of(Property.DOCVALUES, true)),
    FLOAT("pfloat", "solr.FloatPointField", Map.of(Property.DOCVALUES, true)),
    DOUBLE("pdouble", "solr.DoublePointField", Map.of(Property.DOCVALUES, true)),
    DATE("pdate", "solr.DatePointField", Map.of(Property.DOCVALUES, true)),
    BOOLEAN("boolean", "solr.BoolField"),
    
    // Some field are generated by Solr for responses etc. To still maintain a list of those,
    // this type marks a field as Solr generated.
    INTERNAL(null, null),
    
    // TODO: Especially textfields do have more than this (analysers, tokenizers, ...).
    //       We do not yet depict these in this class and it might be better suited for a class on its own.
    //       https://solr.apache.org/guide/8_8/field-type-definitions-and-properties.html#field-type-definitions-in-schema-xml
    TEXT_EN("text_en", "solr.TextField"),
    TEXT_GENERAL("text_general", "solr.TextField", Map.of(Property.MULTIVALUED, true)),
    TEXT_GENERAL_REV("text_general_rev", "solr.TextField"),
    ALPHAONLYSORT("alphaOnlySort", "solr.TextField");
    
    // https://solr.apache.org/guide/8_8/defining-fields.html#optional-field-type-override-properties
    // Also saving the implicit default here...
    public enum Property {
        INDEXED(true), STORED(true), DOCVALUES, MULTIVALUED;
        
        private final boolean def;
        Property() { this.def=false; }
        Property(boolean def) { this.def = def; }
        public boolean getDefault() { return def; }
    }
    
    private final String typeName;
    private final String typeClass;
    // TODO: Field types have a few non-boolean properties. We might need to address this later by using a wrapping class
    private final Map<Property,Boolean> properties;
    
    // TODO: Later on, we should be able to save more configuration aspects as Analysers (including Tokenizers, Filters, ...)
    //       and Similarity.
    
    public SolrFieldType getTypeByName(String typeName) {
        return lookup.get(typeName);
    }
    private final static HashMap<String, SolrFieldType> lookup = new HashMap<>();
    static {
        for (SolrFieldType st : SolrFieldType.values()) {
            lookup.put(st.getName(), st);
        }
    }
    
    SolrFieldType(String typeName, String typeClass) {
        this.typeName = typeName;
        this.typeClass = typeClass;
        // immutable empty map
        this.properties = Map.of();
    }
    
    SolrFieldType(String typeName, String typeClass, Map<Property,Boolean> properties) {
        this.typeName = typeName;
        this.typeClass = typeClass;
        this.properties = properties;
    }
    
    public String getName() {
        return typeName;
    }
    public String getTypeClass() {
        return typeClass;
    }
    public boolean hasProperty(Property p) {
        return properties.containsKey(p);
    }
    public Optional<Boolean> getProperty(Property p) { return Optional.ofNullable(properties.get(p)); }
    public Map<Property, Boolean> getProperties() { return properties; }
}
